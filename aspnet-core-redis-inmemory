# fatih çakıroğlu udemy redis eğitimi notları

****3**** caching nedir ?

* hızlı olması açısından sitelerimizin bu mekanizmaları kullanırız
* 2 çeşit cache var => in memory (private) ve distributed (shared) cache yapıları var


****4**** in memory (private) cache
* uygulama verilerini, uygulamayı barındıran web server ın ram in memory sinde tutar
* veriyi çekmeden önce cache de var mı yok mu diye bakılır, yoksa veritabanına gidilir, kullanıcıya vermeden önce de 3.cü adımda cache e kaydedilir. 
sonraki her çekişde cache den okuma yapar.
* handikapı şu, eğer 2 client varsa ve biri 10da biri 11 de veriyi çekmişse db den, ve de 10-11 arası db bir değişiklik olmuşsa 
farklı datalar üzerinde çalışıyor olacaklar. burada veri tutarsızlığı meydana gelir.
* key leri kişi bazlı tutsak bile sorunlara neden olabilir, EAKGUL_DEVICELIST gibi gibi.


****5**** distrubuted (shared) cache
* ayrı bir server da,server içinde çalışan bir servis aracılığıyla çalışan yapı
* uygulama sunucusu kapansa veya crash olsa dahi cache sunucusu ayrı bir yerde çalıştığı için buradaki veriler kaybolmayacak
* sunucuya giden farklı client lar olsa dahi hepsi tek bir cache servis ten alacağı için veri tutarlılığı olacaktır

****6**** On-Demand ve PrePopulation Caching nedir ?
* cache lenecek datalar çok fazla değişmeyen data olmalı
* cache lenecek datalar çok sık kullanılan datalar olmalı
* on demand     => dataya ihtiyacım olan ilk aşamada cache lemek
* prepopulation => datayı uygulama daha ayağa kalkarken cache lemek
*

****7**** Cache ömrü (Absolute time ve Sliding time) nedir ?
* Absolute time => kesin ömür zamanı yani örneğin 5 dk olarak set edilirse, 5 dk sonra kesin olarak data gider
* Sliding time  => inaktif kalma zamanıdır, yani örneğin 5 dk olarak set edilirse eğer 5 dk içinde tekrar bir işlem görürse 5 dk daha ömrü uzar. Dezaantaj olarak
1 gün boyunca o cache dataya erişim olabilir, bu durumda kullanıcı sürekli eski kayıtlara ulaşıyor olabilir. Bunu da absolute time da tanımlayarak kırabiliriz. Yani
örneğin 2dk buna diğerine 10dk verirsek sadece 5 kere tekrarlanmasına izin vermiş oluruz.

****8****  Kurs esnasında kullanılan program ve versionları
* dotnet core sdk v3
* vs 2019
* redis windows 3.0

****9****  AddMemoryCache() servis ve IMemoryCache interface
* AddMemoryCache() servisi startup servislere eklnirse ve de IMemoryCache interface i cache leme yapılacak class ın contructor ında dependency injection ile alınırsa
cache leme işlemlerine başlayabilirler

****10****  IMemoryCache Get() ve set() methodu
* dataları serialize ettikten sonra get ve set methodları ile dataları cache leyebiliriz
* datalar key value şeklinde depolanır, dictionary koleksiyon gibi
* _memoryCache.Set<string>("zaman",Datetime.Now.ToString()) ile setleme yapılır ,_memoryCache.Get<string>("zaman"); ile de okuma yapılır

****11**** IMemoryCache TryGetValue() ve Remove() methodu
* data cahce te mi değil mi diye kontrlü 2 yolla yapılır,
 1.ci yol     ; if string.isnullorempty(_memoryCache.Get<string>("zaman")) 
 2.ci yol ise ; _memoryCache.Trygetvalue("zaman",string zamanCache) ile var mı yok mu diye kontrl edilir; eğer varsa zamanCache dolu gelir, 
 hem de if true döner devam eder
* GetOrCreate methodu ise, parametre var mı diye bakar, yoksa dolduru
_memoryCache.GetOrCreate<string>("zaman", entry => { return datetime.now.tostring();  });

****12****  AbsoluteExpiration ve SlidingExpiration
* Memorycacheentryoption class ından instance alınması ile aşağıdaki parametreler kullanılır
* AbsoluteExpiration => cache in kesin net ömrünü verir (datatime.now.second)
* SlidingExpiration  => inaktif süresi, yani verilen sürede işlem olmazsa silinir (timespan)
* Memorycacheentryoption in  instance ı da set ile birlikte kullanılır ve .cü parametre olarak ataması yapılır

****13****  Cache Priority
* Memorycacheentryoption class instance ında priorty attribute üne cacheitempriority enum ında bulunan öncelik seçenekleirnden biri seçilir
* yüksek, düşük , neverremove gibi seçenekleri vardır


****14****  RegisterPostEvictionCallback method
* memory den bir data silindiğinde hangi nedenle silindi bilgisni RegisterPostEvictionCallback methodu ile görebiliyoruz.
*  Memorycacheentryoption in  instance ı RegisterPostEvictionCallback methodu bir delege istiyor, delege e  key value reason state parametreleirni alıyor bu 
durumda kod bloğu  

Memorycacheentryoption in  instance ı .RegisterPostEvictionCallback(  ( key ,value, reason, state) => 
{ 
_memoryCache.Set<string>("callback",$({key} -> {value} => sebep => {reason} )); // ile cahce ten okuma yapılır
}  )

****15**** Complex types caching
* örneğin product class ı oluşturuldu,id name ve price a sahip. bu class ı doldurduğumuzda imemorycache te cache lemek için serialize etmemize gerek yok
Product prod = new(){Id = 1, Name =  "Kalem", Price = 200};
_memoryCache.Set<Product>("product:1",prod);
// gösterme için ise => _memoryCache.Get<Product>("product:1");
* view de bu datayı viewbag ile aldığımızı varsayayrsak
viewbag.product = _memoryCache.Get<Product>("product:1");  => gibi
bunu okumak için;
Product p = viewbag.product as Product; olarak alabiliriz.
****** NOT : as keyword ü cast edebilirse veriyi döner, cast edemezse null gönderir ve hatasız devam eder
            is keyword ü ise cast edebiliyorsa true yoksa false döner
* bu ve benzeri tüm veri tiplerini _memoryCache.Set<double> , _memoryCache.Set<int> gibi gibi


****16****                Redis nedir ?
* Remote DIctionary Server ın kısaltılmış halidir.
* dataları memory de tutan bir nosql veritabanıdır.
* key value şeklinde verileri tutar, ve tüm veri tiplerini desteklemekedir.
* verileri tek bir versiyonda tutacağı için herkese aynı cahce i sağlar
* kullanıcıların session verilerini de redis üzerinde tutabiliriz

****17****                Chocolatey ile Redis Kurulum(windows)
* windows için redis in resmi bir sürümü bulunmamaktadır, o yüzden genelde docker üzerine kurulur
* redis güncel sürümğ şuan için 7.0 ama windows için güncel sürümü open source olduğu için orası 3.0.5 te
* paket yöneticisi olarak Chocolatey kurulur,
* kurulum adresi => https://chocolatey.org/
* kurulumu için https://chocolatey.org/install 
* burada ilk olarak Get-ExecutionPolicy kodunu power shell i yönetici olarak çalıştırıp başlıyoruz. eğer Restricted mesajı alınırsa 
 Set-ExecutionPolicy AllSigned kodunu çalıştırıyoruz, ya da  Set-ExecutionPolicy Bypass -Scope Process bu kodu
* sonrasında aşağıdaki kod çalıştırılır
Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
* aşağıdaki kod bloğu ile de redis i chocolotlay ile kurulumunu sağlıyoruz , power shell den devam ediyıruz
    choco install redis-64 --version 3.0.503
* kurulum sonrası redis server ı ayağa kaldırmak için power shell den devam ediyoruz
=> redis_server komutu ile kurulumu sağlıyoruz
* yeni bir power shell i yönetici pozisyonunda çalıştırıyoruz
 => redis_cli komutu ile redis client a geçiş yapmış oluyoruz; burada komut satırı 127.0.0.1:6379> şeklinde görünür olacaktır.
* komut satırına ping yazıldığında PONG cevabı alınıyorsa redis başarılı bir şekilde kurulmuş demektir.
 


****18****             Docker Container iler Redis Server ayağa kaldırma
*power shell yine yönetici olarak çalıştıırlır,
* komut satırına => 

